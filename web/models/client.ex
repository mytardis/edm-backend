defmodule EdmBackend.Client do
  @moduledoc """
  Represents a client
  """

  require Logger
  use EdmBackend.Web, :model
  alias EdmBackend.Repo
  alias EdmBackend.Client
  alias EdmBackend.Group
  alias EdmBackend.Credential
  alias EdmBackend.GroupMembership
  alias EdmBackend.Source
  alias Ecto.Multi
  import Ecto.Query

  schema "clients" do
    field :name, :string
    field :attributes, :map
    has_many :credentials, Credential
    has_many :group_memberships, GroupMembership
    has_many :groups, through: [:group_memberships, :group]
    has_many :sources, Source, foreign_key: :owner_id
    timestamps()
  end

  @allowed ~w(name attributes)a
  @required ~w(name)a

  def changeset(model, params \\ %{}) do
    model |> cast(params, @allowed)
          |> validate_required(@required)
  end

  @doc """
  Gets or creates a user for given auth provider
  """
  def get_or_create(provider, client_info, extra_data \\ %{})

  def get_or_create(provider, client_info, extra_data) when is_atom(provider) do
    get_or_create(Atom.to_string(provider), client_info, extra_data)
  end

  def get_or_create(provider, %{id: uid, name: name}, extra_data) do
    query = from cred in Credential,
              where: cred.remote_id == ^uid,
              where: cred.auth_provider == ^provider,
              preload: [:client]
    transaction = case Repo.one(query) do
      nil ->
        Multi.new
          |> Multi.insert(:create_client, %Client{} |> Client.changeset(%{name: name}))
          |> Multi.run(:create_credential, fn %{create_client: client} ->
            %Credential{client: client}
              |> Credential.changeset(%{
                auth_provider: provider,
                remote_id: uid,
                extra_data: extra_data})
              |> Repo.insert
            end)
          |> Multi.run(:create_default_group, &create_default_group(&1.create_client))
      client_credential ->
        Multi.new
          |> Multi.update(:update_credential, client_credential |> Credential.changeset(%{extra_data: extra_data}))
    end
    case transaction |> Repo.transaction do
      {:ok, %{create_client: client}} -> {:ok, client}
      {:ok, %{update_credential: %{client: client}}} -> {:ok, client}
    end
  end

  @doc """
  Adds a client to a group
  """
  def add_to_group(client, group) do
    %GroupMembership{
      client: client,
      group: group
    } |> GroupMembership.changeset
      |> Repo.insert
  end

  # Calculates the default group name for a user
  defp default_group_name(%Client{name: name} = client, group_suffix \\ 0) do
    group_name = case group_suffix do
      0 ->
        name
      suffix ->
        "#{name}_#{suffix}"
    end

    query = from g in Group, where: g.name == ^group_name
    case Repo.one(query) do
      nil -> group_name
      _ -> default_group_name(client, group_suffix + 1)
    end
  end

  @doc """
  Creates a default froup for a client, adding them to that group.
  This function is typically used when creating new users to enforce the
  one group per client rule.
  """
  def create_default_group(client) do
    result = %Group{} |> Group.changeset(%{
      name: default_group_name(client),
      description: "Autogenerated group for user #{client.id}"
      }) |> Repo.insert
    case result do
      {:ok, group} ->
        add_to_group(client, group)
        {:ok, group}
      {:error, error} -> {:error, error}
    end
  end

  def create_default_group!(client) do
    case create_default_group(client) do
      {:ok, group} -> group
      {:error, error} -> raise error
    end
  end

  @doc """
  Generates a list of groups that a client belongs to
  """
  def all_groups(client) do
    groups = client |> Repo.preload(:groups) |> Map.get(:groups)
    case groups do
      [] ->
        [create_default_group!(client)]
      _ ->
        groups
    end
  end

  def all_sources(client) do
    client |> Repo.preload(:sources)
           |> Map.get(:sources)
  end

  @doc """
  Returns a list of clients who are members of a group. The group may be
  specified as either a group struct or string representing the group's name.
  """
  def members(%Group{} = group) do
    %{clients: members} = group |> Repo.preload(:clients)
    members
  end

  def members(group) do
    {:ok, group} = Group.get_by_name(group)
    members(group)
  end

  @doc """
  Adds a client to a group. The group may be specified as either a group struct
  or string representing the group's name
  """
  def add_member(%Client{} = client, %Group{} = group) do
    %GroupMembership{group: group, client: client }
      |> GroupMembership.changeset()
      |> Repo.insert
  end

  def add_member(client, group) do
    {:ok, group} = Group.get_by_name(group)
    client |> add_member(group)
  end

  @doc """
  Removes a client to a group. The group may be specified as either a group
  struct or string representing the group's name
  """
  def remove_member(%Client{id: client_id} = client, %Group{id: group_id}) do
    if length(all_groups(client)) < 2 do
      {:error, "A client must have at least one group at all times"}
    else
      query = from m in GroupMembership,
                where: m.client_id == ^client_id,
                where: m.group_id == ^group_id
      query |> Repo.delete_all
    end
  end

  def remove_member(client, group) do
    {:ok, group} = Group.get_by_name(group)
    client |> remove_member(group)
  end

  @doc """
  Determines whether the given client is a member of the specified group. The
  group may be specified as either a group struct or string representing the
  group's name
  """
  def member_of?(client, %Group{id: gid}) do
    client |> all_groups |> member_of?(gid)
  end

  def member_of?(_, nil) do
    false
  end

  def member_of?([], _target_gid) do
    false
  end

  def member_of?([%Group{id: gid}|_tail], target_gid) when gid == target_gid do
    true
  end

  def member_of?([_head|tail], target_gid) do
    member_of?(tail, target_gid)
  end

  def member_of?(client, group_name) do
    group = Group |> where([g], g.name == ^group_name) |> Repo.one
    member_of?(client, group)
  end

end
